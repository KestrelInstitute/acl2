(UNSET-WATERFALL-PARALLELISM)
(ASSIGN SCRIPT-MODE T)
 T
(SET-LD-PROMPT T STATE)
 T
ACL2 !>>(SET-INHIBITED-SUMMARY-TYPES '(TIME STEPS))
 (TIME STEPS)
ACL2 !>>(SET-INHIBIT-OUTPUT-LST '(PROOF-TREE))
 (PROOF-TREE)
ACL2 !>>(IN-PACKAGE "ACL2")
 "ACL2"
ACL2 !>>(DEFSTOBJ SUB$C FLD0$C)

Summary
Form:  ( DEFSTOBJ SUB$C ...)
Rules: NIL
 SUB$C
ACL2 !>>(DEFSTOBJ TOP$C (SUB0$C :TYPE SUB$C))

Summary
Form:  ( DEFSTOBJ TOP$C ...)
Rules: NIL
 TOP$C
ACL2 !>>(DEFUN SUB$AP (X)
               (DECLARE (XARGS :GUARD T))
               (AND (CONSP X)
                    (NULL (CDR X))
                    (OR (NATP (CAR X)) (NULL (CAR X)))))

Since SUB$AP is non-recursive, its admission is trivial.  We observe
that the type of SUB$AP is described by the theorem 
(OR (EQUAL (SUB$AP X) T) (EQUAL (SUB$AP X) NIL)).  We used the :compound-
recognizer rule NATP-COMPOUND-RECOGNIZER and primitive type reasoning.

Computing the guard conjecture for SUB$AP....

The guard conjecture for SUB$AP is trivial to prove.  SUB$AP is compliant
with Common Lisp.

Summary
Form:  ( DEFUN SUB$AP ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:FAKE-RUNE-FOR-TYPE-SET NIL))
 SUB$AP
ACL2 !>>(DEFUN TOP$AP (X)
               (DECLARE (XARGS :GUARD T))
               (AND (CONSP X)
                    (NULL (CDR X))
                    (SUB$AP (CAR X))))

Since TOP$AP is non-recursive, its admission is trivial.  We observe
that the type of TOP$AP is described by the theorem 
(OR (EQUAL (TOP$AP X) T) (EQUAL (TOP$AP X) NIL)).  We used the :type-
prescription rule SUB$AP.

Computing the guard conjecture for TOP$AP....

The guard conjecture for TOP$AP is trivial to prove.  TOP$AP is compliant
with Common Lisp.

Summary
Form:  ( DEFUN TOP$AP ...)
Rules: ((:TYPE-PRESCRIPTION SUB$AP))
 TOP$AP
ACL2 !>>(DEFUN CREATE-TOP$A
               NIL (DECLARE (XARGS :GUARD T))
               (LIST (LIST NIL)))

Since CREATE-TOP$A is non-recursive, its admission is trivial.  We
observe that the type of CREATE-TOP$A is described by the theorem 
(AND (CONSP (CREATE-TOP$A)) (TRUE-LISTP (CREATE-TOP$A))).  

Computing the guard conjecture for CREATE-TOP$A....

The guard conjecture for CREATE-TOP$A is trivial to prove.  CREATE-TOP$A
is compliant with Common Lisp.

Summary
Form:  ( DEFUN CREATE-TOP$A ...)
Rules: NIL
 CREATE-TOP$A
ACL2 !>>(DEFUN SUB0$A (X)
               (DECLARE (XARGS :GUARD (TOP$AP X)))
               (CAR X))

Since SUB0$A is non-recursive, its admission is trivial.  We could
deduce no constraints on the type of SUB0$A.

Computing the guard conjecture for SUB0$A....

The non-trivial part of the guard conjecture for SUB0$A is

Goal
(IMPLIES (AND (TOP$AP X) (NOT (CONSP X)))
         (EQUAL X NIL)).

Q.E.D.

That completes the proof of the guard theorem for SUB0$A.  SUB0$A is
compliant with Common Lisp.

Summary
Form:  ( DEFUN SUB0$A ...)
Rules: ((:DEFINITION NOT)
        (:DEFINITION SUB$AP)
        (:DEFINITION TOP$AP))
 SUB0$A
ACL2 !>>(DEFUN-NX
             UPDATE-SUB0$A (SUB$C X)
             (DECLARE (XARGS :STOBJS SUB$C
                             :GUARD (AND (TOP$AP X) (NATP (FLD0$C SUB$C)))))
             (LIST SUB$C))

Since UPDATE-SUB0$A is non-recursive, its admission is trivial.  We
observe that the type of UPDATE-SUB0$A is described by the theorem
(AND (CONSP (UPDATE-SUB0$A SUB$C X)) (TRUE-LISTP (UPDATE-SUB0$A SUB$C X))).
We used primitive type reasoning.

(UPDATE-SUB0$A SUB$C *) => *.

Computing the guard conjecture for UPDATE-SUB0$A....

The guard conjecture for UPDATE-SUB0$A is trivial to prove.  UPDATE-SUB0$A
is compliant with Common Lisp.

Summary
Form:  ( DEFUN UPDATE-SUB0$A ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 (:DEFUN-NX UPDATE-SUB0$A)
ACL2 !>>(DEFUN-NX TOP-CORR (TOP$C X)
                  (DECLARE (XARGS :STOBJS TOP$C))
                  (EQUAL TOP$C X))

Since TOP-CORR is non-recursive, its admission is trivial.  We observe
that the type of TOP-CORR is described by the theorem 
(OR (EQUAL (TOP-CORR TOP$C X) T) (EQUAL (TOP-CORR TOP$C X) NIL)). 
We used primitive type reasoning.

(TOP-CORR TOP$C *) => *.

Computing the guard conjecture for TOP-CORR....

The guard conjecture for TOP-CORR is trivial to prove.  TOP-CORR is
compliant with Common Lisp.

Summary
Form:  ( DEFUN TOP-CORR ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
 (:DEFUN-NX TOP-CORR)
ACL2 !>>(DEFTHM CREATE-TOP{CORRESPONDENCE}
                (TOP-CORR (CREATE-TOP$C) (CREATE-TOP$A))
                :RULE-CLASSES NIL)

Q.E.D.

Summary
Form:  ( DEFTHM CREATE-TOP{CORRESPONDENCE} ...)
Rules: ((:DEFINITION CREATE-SUB$C)
        (:DEFINITION CREATE-TOP$C)
        (:DEFINITION TOP-CORR)
        (:EXECUTABLE-COUNTERPART CONS)
        (:EXECUTABLE-COUNTERPART CREATE-TOP$A)
        (:EXECUTABLE-COUNTERPART EQUAL))
 CREATE-TOP{CORRESPONDENCE}
ACL2 !>>(DEFTHM CREATE-TOP{PRESERVED}
                (TOP$AP (CREATE-TOP$A))
                :RULE-CLASSES NIL)

Q.E.D.

Summary
Form:  ( DEFTHM CREATE-TOP{PRESERVED} ...)
Rules: ((:EXECUTABLE-COUNTERPART CREATE-TOP$A)
        (:EXECUTABLE-COUNTERPART TOP$AP))
 CREATE-TOP{PRESERVED}
ACL2 !>>(DEFTHM SUB0{CORRESPONDENCE}
                (IMPLIES (AND (TOP-CORR TOP$C TOP) (TOP$AP TOP))
                         (EQUAL (SUB0$C TOP$C) (SUB0$A TOP)))
                :RULE-CLASSES NIL)
Goal'

Q.E.D.

Summary
Form:  ( DEFTHM SUB0{CORRESPONDENCE} ...)
Rules: ((:DEFINITION NATP)
        (:DEFINITION NTH)
        (:DEFINITION SUB$AP)
        (:DEFINITION SUB0$A)
        (:DEFINITION SUB0$C)
        (:DEFINITION TOP$AP)
        (:DEFINITION TOP-CORR)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL))
 SUB0{CORRESPONDENCE}
ACL2 !>>(DEFTHM UPDATE-SUB0{CORRESPONDENCE}
                (IMPLIES (AND (TOP-CORR TOP$C TOP)
                              (SUB$CP SUB$C)
                              (TOP$AP TOP)
                              (NATP (FLD0$C SUB$C)))
                         (TOP-CORR (UPDATE-SUB0$C SUB$C TOP$C)
                                   (UPDATE-SUB0$A SUB$C TOP)))
                :RULE-CLASSES NIL)
Goal'

Q.E.D.

Summary
Form:  ( DEFTHM UPDATE-SUB0{CORRESPONDENCE} ...)
Rules: ((:DEFINITION FLD0$C)
        (:DEFINITION LENGTH)
        (:DEFINITION NATP)
        (:DEFINITION NTH)
        (:DEFINITION SUB$AP)
        (:DEFINITION SUB$CP)
        (:DEFINITION TOP$AP)
        (:DEFINITION TOP-CORR)
        (:DEFINITION UPDATE-NTH)
        (:DEFINITION UPDATE-SUB0$A)
        (:DEFINITION UPDATE-SUB0$C)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL))
 UPDATE-SUB0{CORRESPONDENCE}
ACL2 !>>(DEFTHM EQUAL-LEN-1
                (EQUAL (EQUAL (LEN X) 1)
                       (AND (CONSP X) (ATOM (CDR X)))))

Splitter note (see :DOC splitter) for Goal (2 subgoals).
  if-intro: ((:DEFINITION ATOM) (:DEFINITION LEN))

Subgoal 2
Subgoal 1
Subgoal 1'
Subgoal 1''

([ A key checkpoint:

Subgoal 1
(IMPLIES (AND (CONSP X)
              (EQUAL (+ 1 (LEN (CDR X))) 1))
         (NOT (CONSP (CDR X))))

Normally we would attempt to prove Subgoal 1'' by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

])

Perhaps we can prove *1 by induction.  One induction scheme is suggested
by this conjecture.  

We will induct according to a scheme suggested by (LEN X).  This suggestion
was produced using the :induction rule LEN.  If we let (:P X) denote
*1 above then the induction scheme we'll use is
(AND (IMPLIES (NOT (CONSP X)) (:P X))
     (IMPLIES (AND (CONSP X) (:P (CDR X)))
              (:P X))).
This induction is justified by the same argument used to admit LEN.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.
Subgoal *1/2
Subgoal *1/1

Splitter note (see :DOC splitter) for Subgoal *1/1 (3 subgoals).
  if-intro: ((:DEFINITION ATOM))

Subgoal *1/1.3
Subgoal *1/1.2
Subgoal *1/1.2'
Subgoal *1/1.1

*1 is COMPLETED!
Thus key checkpoint Goal is COMPLETED!

Q.E.D.

Summary
Form:  ( DEFTHM EQUAL-LEN-1 ...)
Rules: ((:DEFINITION ATOM)
        (:DEFINITION LEN)
        (:DEFINITION NOT)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:INDUCTION LEN)
        (:TYPE-PRESCRIPTION LEN))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION ATOM))
 EQUAL-LEN-1
ACL2 !>>(DEFTHM UPDATE-SUB0{PRESERVED}
                (IMPLIES (AND (SUB$CP SUB$C)
                              (TOP$AP TOP)
                              (NATP (FLD0$C SUB$C)))
                         (TOP$AP (UPDATE-SUB0$A SUB$C TOP)))
                :RULE-CLASSES NIL)
Goal'

Q.E.D.

Summary
Form:  ( DEFTHM UPDATE-SUB0{PRESERVED} ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:DEFINITION ATOM)
        (:DEFINITION FLD0$C)
        (:DEFINITION LENGTH)
        (:DEFINITION NATP)
        (:DEFINITION NTH)
        (:DEFINITION SUB$AP)
        (:DEFINITION SUB$CP)
        (:DEFINITION TOP$AP)
        (:DEFINITION UPDATE-SUB0$A)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE EQUAL-LEN-1))
 UPDATE-SUB0{PRESERVED}
ACL2 !>>(DEFTHM SUB0-AGAIN{CORRESPONDENCE}
                (IMPLIES (AND (TOP-CORR TOP$C TOP) (TOP$AP TOP))
                         (EQUAL (SUB0$C TOP$C) (SUB0$A TOP)))
                :RULE-CLASSES NIL)
Goal'

Q.E.D.

Summary
Form:  ( DEFTHM SUB0-AGAIN{CORRESPONDENCE} ...)
Rules: ((:DEFINITION NATP)
        (:DEFINITION NTH)
        (:DEFINITION SUB$AP)
        (:DEFINITION SUB0$A)
        (:DEFINITION SUB0$C)
        (:DEFINITION TOP$AP)
        (:DEFINITION TOP-CORR)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL))
 SUB0-AGAIN{CORRESPONDENCE}
ACL2 !>>(DEFTHM UPDATE-SUB0-AGAIN{CORRESPONDENCE}
                (IMPLIES (AND (TOP-CORR TOP$C TOP)
                              (SUB$CP SUB$C)
                              (TOP$AP TOP)
                              (NATP (FLD0$C SUB$C)))
                         (TOP-CORR (UPDATE-SUB0$C SUB$C TOP$C)
                                   (UPDATE-SUB0$A SUB$C TOP)))
                :RULE-CLASSES NIL)
Goal'

Q.E.D.

Summary
Form:  ( DEFTHM UPDATE-SUB0-AGAIN{CORRESPONDENCE} ...)
Rules: ((:DEFINITION ATOM)
        (:DEFINITION FLD0$C)
        (:DEFINITION LENGTH)
        (:DEFINITION NATP)
        (:DEFINITION NTH)
        (:DEFINITION SUB$AP)
        (:DEFINITION SUB$CP)
        (:DEFINITION TOP$AP)
        (:DEFINITION TOP-CORR)
        (:DEFINITION UPDATE-NTH)
        (:DEFINITION UPDATE-SUB0$A)
        (:DEFINITION UPDATE-SUB0$C)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE EQUAL-LEN-1))
 UPDATE-SUB0-AGAIN{CORRESPONDENCE}
ACL2 !>>(DEFTHM UPDATE-SUB0-AGAIN{PRESERVED}
                (IMPLIES (AND (SUB$CP SUB$C)
                              (TOP$AP TOP)
                              (NATP (FLD0$C SUB$C)))
                         (TOP$AP (UPDATE-SUB0$A SUB$C TOP)))
                :RULE-CLASSES NIL)
Goal'

Q.E.D.

Summary
Form:  ( DEFTHM UPDATE-SUB0-AGAIN{PRESERVED} ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:DEFINITION ATOM)
        (:DEFINITION FLD0$C)
        (:DEFINITION LENGTH)
        (:DEFINITION NATP)
        (:DEFINITION NTH)
        (:DEFINITION SUB$AP)
        (:DEFINITION SUB$CP)
        (:DEFINITION TOP$AP)
        (:DEFINITION UPDATE-SUB0$A)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE EQUAL-LEN-1))
 UPDATE-SUB0-AGAIN{PRESERVED}
ACL2 !>>(DEFABSSTOBJ TOP
                     :RECOGNIZER (TOPP :LOGIC TOP$AP :EXEC TOP$CP)
                     :CREATOR (CREATE-TOP :LOGIC CREATE-TOP$A
                                          :EXEC CREATE-TOP$C)
                     :CORR-FN TOP-CORR
                     :EXPORTS ((SUB0 :LOGIC SUB0$A
                                     :EXEC SUB0$C
                                     :UPDATER UPDATE-SUB0)
                               (SUB0-AGAIN :LOGIC SUB0$A
                                           :EXEC SUB0$C
                                           :UPDATER UPDATE-SUB0)
                               (UPDATE-SUB0 :LOGIC UPDATE-SUB0$A
                                            :EXEC UPDATE-SUB0$C)))

Summary
Form:  ( DEFABSSTOBJ TOP ...)
Rules: NIL
 TOP
ACL2 !>>(DEFUN FOO (TOP)
               (DECLARE (XARGS :STOBJS TOP))
               (STOBJ-LET ((SUB$C (SUB0 TOP)))
                          (SUB$C SUB$C-VAL)
                          (LET* ((SUB$C (UPDATE-FLD0$C 1 SUB$C))
                                 (SUB$C-VAL (FLD0$C SUB$C)))
                                (MV SUB$C SUB$C-VAL))
                          (MV TOP SUB$C-VAL)))

Since FOO is non-recursive, its admission is trivial.  We observe that
the type of FOO is described by the theorem 
(AND (CONSP (FOO TOP)) (TRUE-LISTP (FOO TOP))).  We used primitive
type reasoning.

(FOO TOP) => (MV TOP *).

Computing the guard conjecture for FOO....

The non-trivial part of the guard conjecture for FOO is

Goal
(IMPLIES (TOPP TOP)
         (LET ((SUB$C (SUB0 TOP)))
              (MV-LET (SUB$C)
                      (LET* ((SUB$C (UPDATE-FLD0$C 1 SUB$C))
                             (SUB$C-VAL (FLD0$C SUB$C)))
                            (LIST SUB$C SUB$C-VAL))
                      (NATP (FLD0$C SUB$C))))).
Goal'

Q.E.D.

That completes the proof of the guard theorem for FOO.  FOO is compliant
with Common Lisp.

Summary
Form:  ( DEFUN FOO ...)
Rules: ((:DEFINITION FLD0$C)
        (:DEFINITION NATP)
        (:DEFINITION NOT)
        (:DEFINITION SUB$AP)
        (:DEFINITION SUB0)
        (:DEFINITION SUB0$A)
        (:DEFINITION TOP$AP)
        (:DEFINITION TOPP)
        (:DEFINITION UPDATE-FLD0$C)
        (:DEFINITION UPDATE-NTH)
        (:EXECUTABLE-COUNTERPART CONS)
        (:EXECUTABLE-COUNTERPART MV-NTH)
        (:EXECUTABLE-COUNTERPART NATP)
        (:EXECUTABLE-COUNTERPART NTH)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL))
 FOO
ACL2 !>>(DEFSTOBJ SUB$C-CONG FLD0$C-CONG
                  :CONGRUENT-TO SUB$C)

Summary
Form:  ( DEFSTOBJ SUB$C-CONG ...)
Rules: NIL
 SUB$C-CONG
ACL2 !>>(DEFUN FOO-BAD (TOP)
               (DECLARE (XARGS :STOBJS TOP))
               (STOBJ-LET ((SUB$C (SUB0 TOP))
                           (SUB$C-CONG (SUB0-AGAIN TOP)
                                       UPDATE-SUB0))
                          (SUB$C SUB$C-VAL SUB$C-CONG SUB$C-CONG-VAL)
                          (LET* ((SUB$C (UPDATE-FLD0$C 1 SUB$C))
                                 (SUB$C-CONG (UPDATE-FLD0$C 2 SUB$C-CONG))
                                 (SUB$C-VAL (FLD0$C SUB$C))
                                 (SUB$C-CONG-VAL (FLD0$C SUB$C-CONG)))
                                (MV SUB$C
                                    SUB$C-VAL SUB$C-CONG SUB$C-CONG-VAL))
                          (MV TOP SUB$C-VAL SUB$C-CONG-VAL)))


ACL2 Error in ( DEFUN FOO-BAD ...):  The accessors SUB0 and SUB0-AGAIN
ultimately invoke the same accessor, SUB0$C, of the same concrete stobj,
TOP$C.  The form 
(STOBJ-LET ((SUB$C (SUB0 TOP))
            (SUB$C-CONG (SUB0-AGAIN TOP)
                        UPDATE-SUB0))
           (SUB$C SUB$C-VAL SUB$C-CONG SUB$C-CONG-VAL)
           (LET* ((SUB$C (UPDATE-FLD0$C 1 SUB$C))
                  (SUB$C-CONG (UPDATE-FLD0$C 2 SUB$C-CONG))
                  (SUB$C-VAL (FLD0$C SUB$C))
                  (SUB$C-CONG-VAL (FLD0$C SUB$C-CONG)))
                 (MV SUB$C
                     SUB$C-VAL SUB$C-CONG SUB$C-CONG-VAL))
           (MV TOP SUB$C-VAL SUB$C-CONG-VAL))
is thus illegal.  See :DOC stobj-let.


Summary
Form:  ( DEFUN FOO-BAD ...)
Rules: NIL

ACL2 Error in ( DEFUN FOO-BAD ...):  See :DOC failure.

******** FAILED ********
ACL2 !>>(DEFTHM CREATE-TOP2{CORRESPONDENCE}
                (TOP-CORR (CREATE-TOP) (CREATE-TOP$A))
                :RULE-CLASSES NIL)

Q.E.D.

Summary
Form:  ( DEFTHM CREATE-TOP2{CORRESPONDENCE} ...)
Rules: ((:DEFINITION CREATE-TOP)
        (:DEFINITION TOP-CORR)
        (:EXECUTABLE-COUNTERPART CREATE-TOP$A)
        (:EXECUTABLE-COUNTERPART EQUAL))
 CREATE-TOP2{CORRESPONDENCE}
ACL2 !>>(DEFTHM CREATE-TOP2{PRESERVED}
                (TOP$AP (CREATE-TOP$A))
                :RULE-CLASSES NIL)

Q.E.D.

Summary
Form:  ( DEFTHM CREATE-TOP2{PRESERVED} ...)
Rules: ((:EXECUTABLE-COUNTERPART CREATE-TOP$A)
        (:EXECUTABLE-COUNTERPART TOP$AP))
 CREATE-TOP2{PRESERVED}
ACL2 !>>(DEFTHM SUB02{CORRESPONDENCE}
                (IMPLIES (AND (TOP-CORR TOP TOP2) (TOP$AP TOP2))
                         (EQUAL (SUB0 TOP) (SUB0$A TOP2)))
                :RULE-CLASSES NIL)
Goal'

Q.E.D.

Summary
Form:  ( DEFTHM SUB02{CORRESPONDENCE} ...)
Rules: ((:DEFINITION SUB$AP)
        (:DEFINITION SUB0)
        (:DEFINITION SUB0$A)
        (:DEFINITION TOP$AP)
        (:DEFINITION TOP-CORR)
        (:FAKE-RUNE-FOR-TYPE-SET NIL))
 SUB02{CORRESPONDENCE}
ACL2 !>>(DEFTHM SUB02-AGAIN{CORRESPONDENCE}
                (IMPLIES (AND (TOP-CORR TOP TOP2) (TOP$AP TOP2))
                         (EQUAL (SUB0-AGAIN TOP) (SUB0$A TOP2)))
                :RULE-CLASSES NIL)
Goal'

Q.E.D.

Summary
Form:  ( DEFTHM SUB02-AGAIN{CORRESPONDENCE} ...)
Rules: ((:DEFINITION SUB$AP)
        (:DEFINITION SUB0$A)
        (:DEFINITION SUB0-AGAIN)
        (:DEFINITION TOP$AP)
        (:DEFINITION TOP-CORR)
        (:FAKE-RUNE-FOR-TYPE-SET NIL))
 SUB02-AGAIN{CORRESPONDENCE}
ACL2 !>>(DEFTHM UPDATE-SUB02{CORRESPONDENCE}
                (IMPLIES (AND (TOP-CORR TOP TOP2)
                              (SUB$CP SUB$C)
                              (TOP$AP TOP2)
                              (NATP (FLD0$C SUB$C)))
                         (TOP-CORR (UPDATE-SUB0 SUB$C TOP)
                                   (UPDATE-SUB0$A SUB$C TOP2)))
                :RULE-CLASSES NIL)

Q.E.D.

Summary
Form:  ( DEFTHM UPDATE-SUB02{CORRESPONDENCE} ...)
Rules: ((:DEFINITION FLD0$C)
        (:DEFINITION TOP-CORR)
        (:DEFINITION UPDATE-SUB0)
        (:DEFINITION UPDATE-SUB0$A)
        (:EXECUTABLE-COUNTERPART IF))
 UPDATE-SUB02{CORRESPONDENCE}
ACL2 !>>(DEFTHM UPDATE-SUB02{PRESERVED}
                (IMPLIES (AND (SUB$CP SUB$C)
                              (TOP$AP TOP2)
                              (NATP (FLD0$C SUB$C)))
                         (TOP$AP (UPDATE-SUB0$A SUB$C TOP2)))
                :RULE-CLASSES NIL)
Goal'

Q.E.D.

Summary
Form:  ( DEFTHM UPDATE-SUB02{PRESERVED} ...)
Rules: ((:COMPOUND-RECOGNIZER NATP-COMPOUND-RECOGNIZER)
        (:DEFINITION ATOM)
        (:DEFINITION FLD0$C)
        (:DEFINITION LENGTH)
        (:DEFINITION NATP)
        (:DEFINITION NTH)
        (:DEFINITION SUB$AP)
        (:DEFINITION SUB$CP)
        (:DEFINITION TOP$AP)
        (:DEFINITION UPDATE-SUB0$A)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE CAR-CONS)
        (:REWRITE CDR-CONS)
        (:REWRITE EQUAL-LEN-1))
 UPDATE-SUB02{PRESERVED}
ACL2 !>>(DEFABSSTOBJ TOP2
                     :CONCRETE TOP
                     :RECOGNIZER (TOP2P :LOGIC TOP$AP :EXEC TOPP)
                     :CREATOR (CREATE-TOP2 :LOGIC CREATE-TOP$A
                                           :EXEC CREATE-TOP)
                     :CORR-FN TOP-CORR
                     :EXPORTS ((SUB02 :LOGIC SUB0$A
                                      :EXEC SUB0
                                      :UPDATER UPDATE-SUB02)
                               (SUB02-AGAIN :LOGIC SUB0$A
                                            :EXEC SUB0-AGAIN
                                            :UPDATER UPDATE-SUB02)
                               (UPDATE-SUB02 :LOGIC UPDATE-SUB0$A
                                             :EXEC UPDATE-SUB0)))

Summary
Form:  ( DEFABSSTOBJ TOP2 ...)
Rules: NIL
 TOP2
ACL2 !>>(DEFUN FOO2 (TOP2)
               (DECLARE (XARGS :STOBJS TOP2))
               (STOBJ-LET ((SUB$C (SUB02 TOP2)))
                          (SUB$C SUB$C-VAL)
                          (LET* ((SUB$C (UPDATE-FLD0$C 1 SUB$C))
                                 (SUB$C-VAL (FLD0$C SUB$C)))
                                (MV SUB$C SUB$C-VAL))
                          (MV TOP2 SUB$C-VAL)))

Since FOO2 is non-recursive, its admission is trivial.  We observe
that the type of FOO2 is described by the theorem 
(AND (CONSP (FOO2 TOP2)) (TRUE-LISTP (FOO2 TOP2))).  We used primitive
type reasoning.

(FOO2 TOP2) => (MV TOP2 *).

Computing the guard conjecture for FOO2....

The non-trivial part of the guard conjecture for FOO2 is

Goal
(IMPLIES (TOP2P TOP2)
         (LET ((SUB$C (SUB02 TOP2)))
              (MV-LET (SUB$C)
                      (LET* ((SUB$C (UPDATE-FLD0$C 1 SUB$C))
                             (SUB$C-VAL (FLD0$C SUB$C)))
                            (LIST SUB$C SUB$C-VAL))
                      (NATP (FLD0$C SUB$C))))).
Goal'

Q.E.D.

That completes the proof of the guard theorem for FOO2.  FOO2 is compliant
with Common Lisp.

Summary
Form:  ( DEFUN FOO2 ...)
Rules: ((:DEFINITION FLD0$C)
        (:DEFINITION NATP)
        (:DEFINITION NOT)
        (:DEFINITION SUB$AP)
        (:DEFINITION SUB0$A)
        (:DEFINITION SUB02)
        (:DEFINITION TOP$AP)
        (:DEFINITION TOP2P)
        (:DEFINITION UPDATE-FLD0$C)
        (:DEFINITION UPDATE-NTH)
        (:EXECUTABLE-COUNTERPART CONS)
        (:EXECUTABLE-COUNTERPART MV-NTH)
        (:EXECUTABLE-COUNTERPART NATP)
        (:EXECUTABLE-COUNTERPART NTH)
        (:EXECUTABLE-COUNTERPART ZP)
        (:FAKE-RUNE-FOR-TYPE-SET NIL))
 FOO2
ACL2 !>>(DEFUN FOO2-BAD (TOP2)
               (DECLARE (XARGS :STOBJS TOP2))
               (STOBJ-LET ((SUB$C (SUB02 TOP2))
                           (SUB$C-CONG (SUB02-AGAIN TOP2)
                                       UPDATE-SUB02))
                          (SUB$C SUB$C-VAL SUB$C-CONG SUB$C-CONG-VAL)
                          (LET* ((SUB$C (UPDATE-FLD0$C 1 SUB$C))
                                 (SUB$C-CONG (UPDATE-FLD0$C 2 SUB$C-CONG))
                                 (SUB$C-VAL (FLD0$C SUB$C))
                                 (SUB$C-CONG-VAL (FLD0$C SUB$C-CONG)))
                                (MV SUB$C
                                    SUB$C-VAL SUB$C-CONG SUB$C-CONG-VAL))
                          (MV TOP2 SUB$C-VAL SUB$C-CONG-VAL)))


ACL2 Error in ( DEFUN FOO2-BAD ...):  The accessors SUB02 and SUB02-AGAIN
ultimately invoke the same accessor, SUB0$C, of the same concrete stobj,
TOP$C.  The form 
(STOBJ-LET ((SUB$C (SUB02 TOP2))
            (SUB$C-CONG (SUB02-AGAIN TOP2)
                        UPDATE-SUB02))
           (SUB$C SUB$C-VAL SUB$C-CONG SUB$C-CONG-VAL)
           (LET* ((SUB$C (UPDATE-FLD0$C 1 SUB$C))
                  (SUB$C-CONG (UPDATE-FLD0$C 2 SUB$C-CONG))
                  (SUB$C-VAL (FLD0$C SUB$C))
                  (SUB$C-CONG-VAL (FLD0$C SUB$C-CONG)))
                 (MV SUB$C
                     SUB$C-VAL SUB$C-CONG SUB$C-CONG-VAL))
           (MV TOP2 SUB$C-VAL SUB$C-CONG-VAL))
is thus illegal.  See :DOC stobj-let.


Summary
Form:  ( DEFUN FOO2-BAD ...)
Rules: NIL

ACL2 Error in ( DEFUN FOO2-BAD ...):  See :DOC failure.

******** FAILED ********
ACL2 !>>Bye.
